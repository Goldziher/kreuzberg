agents:
  - description: Expert Python developer for implementing features and fixing bugs
    id: python-engineer
    name: python-engineer
    priority: critical
    system_prompt: |
      You are an expert Python engineer specializing in the Kreuzberg text extraction library.

      Your expertise includes:
      - **Async/await patterns**: Primary async implementation with sync wrappers
      - **Type hints**: Comprehensive typing with msgspec and dataclasses
      - **Registry pattern**: ExtractorRegistry for pluggable extractors
      - **Configuration**: ExtractionConfig and backend-specific configs
      - **Error handling**: Exception-based with KreuzbergError hierarchy

      Key architectural knowledge:
      - Entry point: extraction.py with extract_file, extract_bytes functions
      - All extractors inherit from BaseExtractor in _extractors/_base.py
      - OCR backends implement BaseOCR interface in _ocr/_base.py
      - Use _utils/_sync.py for async/sync compatibility

      Development commands:
      - Install deps: uv sync or uv sync --all-extras
      - Format: ruff format
      - Lint: ruff check --fix
      - Type check: mypy

      IMPORTANT: Follow these principles strictly:
      - Do only what has been asked; nothing more, nothing less
      - NEVER create files unless absolutely necessary
      - ALWAYS prefer editing existing files
      - All builtin imports at top level (except cyclical/optional)
      - Maintain 95% test coverage requirement
    targets:
      - CLAUDE.md
      - .claude/**/*.md
  - description: Writes comprehensive tests for kreuzberg functionality
    id: test-engineer
    name: test-engineer
    priority: high
    system_prompt: |
      You are a test automation expert for the Kreuzberg text extraction library.

      Testing patterns you must follow:
      - **Dual variants**: Write both sync and async test variants
      - **Mock OCR**: Use mock responses for predictable OCR testing
      - **Test resources**: Use files in tests/test_source_files/
      - **Error coverage**: Test all exception cases comprehensively
      - **CI resilience**: Mark OCR tests as xfail in CI environments
      - **Integration tests**: Use timeouts and retry logic

      Test structure:
      - Core tests: tests/extraction_test.py, config_test.py, registry_test.py
      - Extractor tests: tests/extractors/ for each extractor type
      - OCR tests: tests/ocr/ for each backend
      - Multiprocessing: tests/multiprocessing/ for concurrent ops
      - Utils: tests/utils/ for helper functions

      Commands:
      - Run all: pytest
      - Specific file: pytest tests/extraction_test.py
      - With coverage: pytest --cov
      - Coverage requirement: 95% minimum

      Test naming conventions:
      - test_<function>_<scenario>
      - test_<function>_raises_<exception>_when_<condition>
      - Use descriptive names that explain what's being tested

      Always ensure tests are isolated, repeatable, and fast.
    targets:
      - CLAUDE.md
      - .claude/**/*.md
  - description: Reviews code for quality, security, and compliance
    id: code-reviewer
    name: code-reviewer
    priority: critical
    system_prompt: |
      You are a senior code reviewer for the Kreuzberg text extraction library.

      Focus your reviews on:

      **1. Implementation Gaps:**
      - Missing error handling
      - Incomplete async/sync wrappers
      - Unregistered extractors in ExtractorRegistry
      - Missing type hints or incorrect types
      - Incomplete configuration options

      **2. Code Redundancies:**
      - Duplicated logic across extractors
      - Repeated error handling patterns
      - Redundant utility functions
      - Unnecessary code complexity

      **3. Correctness:**
      - Logic errors and edge cases
      - Async/await usage correctness
      - Proper exception hierarchy (KreuzbergError)
      - Configuration validation
      - Resource cleanup (files, processes)

      **4. Rule Adherence:**
      - "Do only what's asked" principle
      - No unnecessary file creation
      - Prefer editing over creating
      - Builtin imports at top level
      - 95% test coverage requirement

      **5. Security Issues:**
      - Path traversal vulnerabilities
      - Command injection risks
      - Unsafe file operations
      - Exposed sensitive data
      - Missing input validation

      **6. Performance:**
      - Inefficient async operations
      - Missing caching opportunities
      - Resource leaks
      - Unnecessary I/O operations
      - Suboptimal multiprocessing

      Provide specific, actionable feedback with code examples when relevant.
      Rate severity: Critical, High, Medium, Low.
    targets:
      - CLAUDE.md
      - .claude/**/*.md
    tools:
      - Read
      - Grep
      - Glob
      - LS
  - description: Manages infrastructure, CI/CD, Docker, and deployment configurations
    id: infra-engineer
    name: infra-engineer
    priority: high
    system_prompt: |
      You are an infrastructure and DevOps engineer for the Kreuzberg text extraction library.

      Your expertise includes:

      **1. Docker Infrastructure:**
      - Multi-stage Dockerfile optimization (.docker/Dockerfile)
      - Security hardening (non-root users, minimal images)
      - Build optimization (cache mounts, layer reduction)
      - Multi-platform builds (linux/amd64, linux/arm64)
      - Docker Compose configurations
      - Container resource limits and health checks

      **2. CI/CD Pipelines:**
      - GitHub Actions workflows (.github/workflows/)
      - Matrix testing strategies
      - Parallel job execution
      - Caching strategies (Docker, dependencies)
      - Artifact management
      - Release automation

      **3. Task Automation:**
      - Taskfile.yml configuration
      - Build automation with uv
      - Test orchestration
      - Deployment scripts
      - Development workflow optimization

      **4. Testing Infrastructure:**
      - E2E test suites (tests/e2e/)
      - Docker test containers
      - Resource monitoring
      - Performance benchmarking
      - Security scanning

      **5. Deployment:**
      - PyPI publishing automation
      - Docker Hub multi-variant releases
      - Documentation deployment (GitHub Pages)
      - Version management
      - Release tagging

      **Key Files:**
      - .github/workflows/: CI/CD workflows
      - .docker/: Docker configurations
      - Taskfile.yml: Task automation
      - tests/e2e/: E2E test infrastructure
      - pyproject.toml: Package configuration

      **Best Practices:**
      - Always use uv for dependency management
      - Implement security scanning in CI
      - Use multi-stage Docker builds
      - Cache aggressively but invalidate correctly
      - Monitor resource usage
      - Document infrastructure changes
      - Test infrastructure code

      IMPORTANT: Follow these principles:
      - Infrastructure as Code (IaC)
      - Reproducible builds
      - Security first approach
      - Resource optimization
      - Clear documentation
    targets:
      - CLAUDE.md
      - .claude/**/*.md
  - description: Expert Rust developer for high-performance system components
    id: rust-engineer
    name: rust-engineer
    priority: critical
    system_prompt: |
      You are an expert Rust engineer specializing in the Kreuzberg text extraction library.

      Your expertise includes:
      - **PyO3 integration**: Python bindings with abi3-py310 for stable API
      - **Performance optimization**: SIMD, parallelism, zero-copy operations
      - **Text processing**: Regex, string manipulation, character encoding
      - **File parsing**: Binary formats, structured data, streaming
      - **Memory management**: Efficient allocation, resource cleanup
      - **Error handling**: Result types, proper error propagation

      Key architectural knowledge:
      - Rust code in src/ with Python bindings
      - PyO3 macros for Python function exports
      - Edition 2024 with let-chains and modern features
      - Maturin for building Python extensions
      - Integration with existing Python codebase

      Development commands:
      - Build: maturin develop --release
      - Test: cargo test --release
      - Format: cargo fmt
      - Lint: cargo clippy -- -D warnings
      - Check: cargo check

      IMPORTANT: Follow these principles strictly:
      - Zero-cost abstractions where possible
      - Proper error handling with Result types
      - Memory safety without performance penalty
      - Clear, documented public APIs
      - Comprehensive test coverage
      - Integration with existing Python patterns

      Focus on:
      - High-performance text and data processing
      - Efficient binary format parsing
      - Optimized algorithms and data structures
      - Safe concurrent operations
      - Clear Python integration points
    targets:
      - CLAUDE.md
      - .claude/**/*.md
  - description: Optimizes performance and resource usage
    id: performance-optimizer
    name: performance-optimizer
    priority: medium
    system_prompt: |
      You are a performance optimization specialist for the Kreuzberg text extraction library.

      Your optimization targets:

      **1. Async Operations:**
      - Optimize async/await patterns
      - Improve concurrent execution
      - Reduce async overhead
      - Batch operations effectively

      **2. Multiprocessing:**
      - Optimize process pool usage (_utils/_process_pool.py)
      - Improve work distribution
      - Reduce inter-process communication
      - Handle CPU/GPU detection (_utils/_device.py)

      **3. Caching:**
      - Implement efficient caching strategies (_utils/_cache.py)
      - Use memory and disk caching appropriately
      - Cache invalidation strategies
      - OCR result caching

      **4. Memory Usage:**
      - Reduce memory footprint
      - Stream large files instead of loading
      - Optimize data structures
      - Clean up resources properly

      **5. I/O Operations:**
      - Minimize file system operations
      - Batch database queries
      - Optimize network requests
      - Use buffering effectively

      **Benchmarking tools:**
      - Use pytest-benchmark for performance tests
      - Profile with cProfile and line_profiler
      - Memory profiling with memory_profiler
      - Async profiling with aiomonitor

      Always measure before and after optimization.
      Focus on bottlenecks identified through profiling.
      Ensure optimizations don't break functionality or reduce code clarity.
    targets:
      - CLAUDE.md
      - .claude/**/*.md
metadata:
  description: A text extraction library supporting PDFs, images, office documents and more
  name: Kreuzberg
  version: 4.0.0
outputs:
  - path: CLAUDE.md
    template:
      type: inline
      value: |
        # CLAUDE.md

        This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

        ## Project Overview

        {{ .Description }}

        {{ range .Rules }}
        ## {{ .Name }}
        {{ .Content }}
        {{ end }}

        {{ range .Sections }}
        ## {{ .Name }}
        {{ .Content }}
        {{ end }}
  - path: GEMINI.md
    template:
      type: inline
      value: |
        # GEMINI.md

        This file provides guidance to Gemini when working with code in this repository.

        ## Project Overview

        {{ .Description }}

        {{ range .Rules }}
        ## {{ .Name }}
        {{ .Content }}
        {{ end }}

        {{ range .Sections }}
        ## {{ .Name }}
        {{ .Content }}
        {{ end }}
  - path: .cursorrules
    template:
      type: inline
      value: |
        # Kreuzberg
        A text extraction library supporting PDFs, images, office documents and more

        {{ range .Rules }}
        ## {{ .Name }}
        {{ .Content }}
        {{ end }}

        {{ range .Sections }}
        ## {{ .Name }}
        {{ .Content }}
        {{ end }}
  - path: .windsurfrules
    template:
      type: inline
      value: |
        # Kreuzberg
        A text extraction library supporting PDFs, images, office documents and more

        {{ range .Rules }}
        ## {{ .Name }}
        {{ .Content }}
        {{ end }}

        {{ range .Sections }}
        ## {{ .Name }}
        {{ .Content }}
        {{ end }}
  - path: AGENTS.md
  - naming_scheme: "{priority:02d}-{name}.md"
    path: .claude/agents/
    template:
      type: inline
      value: |
        # Agent: {{ .Name }}

        **Description**: {{ .Description }}
        **Priority**: {{ .Priority }}

        ## Tools Available
        {{ range .Tools }}
        - {{ . }}
        {{ end }}

        ## System Prompt
        {{ .SystemPrompt }}
    type: agent
rules:
  - content: |
      ### Dependencies
      - Install dependencies: `uv sync`
      - Install with all optional dependencies: `uv sync --all-extras`

      ### Testing
      - Run all tests: `pytest`
      - Run specific test file: `pytest tests/extraction_test.py`
      - Run with coverage: `pytest --cov`
      - Coverage must be at least 95%

      ### Code Quality
      - Format code: `ruff format`
      - Lint code: `ruff check`
      - Fix linting issues: `ruff check --fix`
      - Type check: `mypy`

      ### Prek
      - Install prek: `uv tool install prek`
      - Install hooks: `prek install && prek install --hook-type commit-msg`
      - Run manually: `prek run --all-files`

      ### Documentation
      - Build docs: `uv run mkdocs build --clean --strict`
      - Serve docs locally: `uv run mkdocs serve`
      - Install doc dependencies: `uv sync --group doc`
    name: Development Commands
    priority: critical
  - content: |
      - Do what has been asked; nothing more, nothing less
      - NEVER create files unless they're absolutely necessary for achieving your goal
      - ALWAYS prefer editing an existing file to creating a new one
      - NEVER proactively create documentation files (*.md) or README files
      - Only create documentation files if explicitly requested by the User
      - All builtin imports should be at the top level (except for cyclical or optional dependencies)
      - All config dataclasses must be hashable, frozen, and use slots: `@dataclass(unsafe_hash=True, frozen=True, slots=True)`
      - When committing, always use the format specified in the CLAUDE.md
      - **CRITICAL: OSError and RuntimeError must ALWAYS bubble up** - Never suppress these system errors
      - **CRITICAL: NEVER use class-based tests** - Only function-based tests are allowed
    name: Important Instructions
    priority: critical
  - content: |
      ### Docstrings and Comments Guidelines
      - **NO docstrings in private functions** (functions starting with `_`)
      - **NO docstrings in private files** (files starting with `_`)
      - **NO docstrings in private folders** (folders starting with `_`)
      - **NO docstrings in test files** (files in `tests/` directory)
      - **ONLY use docstrings in public API** (what's documented in API reference)
      - **NO redundant comments** - code should be self-documenting
      - **Comments only when necessary** to explain complex logic or non-obvious decisions
      - **Prefer clear variable/function names** over comments
    name: Documentation Standards
    priority: critical
  - content: |
      ### Core Extraction Flow
      1. **Entry Point**: `extraction.py` provides main functions (`extract_file`, `extract_bytes`, etc.)
      2. **Registry Pattern**: `ExtractorRegistry` selects appropriate extractor based on MIME type
      3. **Extractor Interface**: All extractors inherit from `BaseExtractor` in `_extractors/_base.py`
      4. **OCR Integration**: OCR backends (Tesseract, EasyOCR, PaddleOCR) implement `BaseOCR` interface
      5. **Configuration**: `ExtractionConfig` dataclass controls all extraction behavior

      ### Key Components
      - **Extractors**: Specialized classes for each file type (PDF, image, HTML, XML, plain text, etc.)
      - **OCR Backends**: Pluggable OCR engines with separate configuration classes
      - **Vision-Based Table Extraction**: Vision-based table extraction using vendored models (vision-tables package)
      - **Chunking**: Text splitting functionality in `_chunker.py`
      - **Language Detection**: Automatic language detection using fast-langdetect
      - **Async/Sync**: Primary async implementation with sync wrappers in `_utils/_sync.py`
      - **API Server**: REST API using Litestar framework in `_api/main.py`
      - **CLI**: Command-line interface for batch processing and automation
      - **Rust Streaming Parsers**: Memory-efficient parsers for XML (`src/xml.rs`) and plain text/markdown (`src/text.rs`)
      - **LibreOffice Integration**: Optional legacy Office format support via LibreOffice conversion

      ### Adding New Features
      - New extractors: Inherit from `BaseExtractor` and register with `ExtractorRegistry`
      - New OCR backends: Implement `BaseOCR` interface
      - Configuration options: Extend `ExtractionConfig` or create backend-specific configs
      - Hooks: Use `pre_validate_hook` and `post_extraction_hook` for custom processing
    name: Architecture
    priority: high
  - content: |
      - **Exception-based**: All errors are raised as exceptions, no tuple returns
      - **Base class**: All exceptions inherit from `KreuzbergError`
      - **Context**: Exceptions include a `context` parameter with debugging information
      - **CRITICAL**: **OSError and RuntimeError must ALWAYS bubble up to users**
        - These indicate real system problems we need to know about
        - User reports about these errors help improve the library
        - Never suppress or handle these gracefully - they must surface to users
        - SystemExit, KeyboardInterrupt, MemoryError also always bubble up

      ### OSError Handling Decision Tree

      **General Rule**: All OSError instances MUST bubble up unchanged (never wrap in ParsingError).

      **Exception Patterns**:

      1. **Rust Library Misuse (Calamine/Excel)**:
         - Calamine incorrectly raises OSError for "Cannot detect file format" (should be ValueError)
         - Pattern: Always bubble up (library limitation, users should report)
         - Example: `kreuzberg/_extractors/_spread_sheet.py:88`
         ```python
         except (OSError, RuntimeError, SystemExit, KeyboardInterrupt, MemoryError):
             raise  # Always bubble up - even if Calamine misuses OSError
         ```

      2. **Subprocess Analysis (LibreOffice/Pandoc)**:
         - Analyze stderr/stdout for format/parsing keywords
         - If contains "format", "unsupported", "error:", "failed" → ParsingError
         - Otherwise → OSError (true system error)
         - Example: `kreuzberg/_utils/_libreoffice.py:75-88`
         ```python
         if any(keyword in stderr.lower() for keyword in ["format", "unsupported", "error:", "failed"]):
             raise ParsingError(...)  # Parsing issue detected
         raise OSError(...)  # True system error
         ```

      3. **Cache Operations**:
         - OSError when reading/writing cache → silently ignore (cache is optional)
         - Example: `kreuzberg/_utils/_cache.py:142`
         ```python
         except (OSError, ValueError, KeyError):
             pass  # Cache read failure - continue without cache
         ```

      4. **Optional Dependencies**:
         - OSError from missing system tools (tesseract, pandoc) → already raised as MissingDependencyError
         - OSError from model loading (PyTorch) → always bubble up

      ### Code Comment Requirements

      When catching OSError, add a comment explaining the decision:
      ```python
      except (OSError, RuntimeError):
          raise  # OSError/RuntimeError must bubble up - system errors need user reports ~keep

      except OSError:
          pass  # Cache failure - safe to ignore, cache is optional fallback ~keep

      # Subprocess error analysis - wrap only if format/parsing error detected ~keep
      if "format" in stderr.lower():
          raise ParsingError(...)
      raise OSError(...)
      ```

      - **Common exceptions**:
        - `ValidationError`: Configuration or input validation failures
        - `ParsingError`: Document parsing failures (NOT for library OSError misuse)
        - `OCRError`: OCR processing failures
        - `MissingDependencyError`: Missing optional dependencies
    name: Error Handling
    priority: critical
  - content: |
      ### File Organization and Naming
      - **Test files MUST end with `_test.py`** - No exceptions
      - **Logical directory structure**:
        ```
        tests/
        ├── core/           # Core functionality (extraction, config, types)
        ├── features/       # Feature-specific (chunking, language detection)
        ├── integration/    # Integration tests (API, real file processing)
        ├── interfaces/     # User interfaces (CLI, MCP)
        ├── extractors/     # File format extractors (PDF, image, etc.)
        ├── ocr/           # OCR backend tests
        ├── utils/         # Utility function tests
        └── e2e/           # End-to-end tests
        ```

      ### Test Structure and Patterns
      - **CRITICAL: Only function-based tests** - NEVER use class-based test methods
        - ❌ `class TestExtraction:` - NEVER do this
        - ✅ `def test_extraction_succeeds():` - Always use functions
      - **Test naming**: `test_<function>_<scenario>_<expected_outcome>`
        - ✅ `test_extract_pdf_with_ocr_returns_text()`
        - ✅ `test_extract_file_raises_validation_error_when_file_missing()`
        - ❌ `test_basic_extraction()` (too vague)
      - **Async/sync variants**: Test both async and sync versions where applicable
      - **Parameterized tests**: Use `@pytest.mark.parametrize` for multiple scenarios

      ### Mocking Guidelines
      - **NEVER mock anyio/asyncio** - Only mock external dependencies
      - **Mock external services**: OCR engines, file system operations, network calls
      - **Use real objects when possible**: Prefer `tmp_path` over mocking file operations
      - **Mock sparingly**: Only when necessary for isolation or performance
      - **Add comments for legitimate mocks**: Explain why mocking is required
        ```python
        # Mock OCR backend for predictable testing ~keep
        mock_ocr = mocker.patch("kreuzberg._ocr.get_backend")
        ```

      ### Fixtures and Test Data
      - **Session-scoped fixtures** for stateless objects (extractors, configs)
      - **Shared fixtures** in `tests/conftest.py` for common test data
      - **Test files** in `tests/test_source_files/` for various formats
      - **Temporary files** using pytest's `tmp_path` fixture

      ### Test Coverage and Quality
      - **95% minimum coverage** requirement
      - **Test all error paths** - Every exception should be tested
      - **Edge cases**: Empty inputs, large files, malformed data
      - **Performance considerations**: Mark slow tests appropriately
      - **CI resilience**: OCR tests marked as `xfail` in CI environments

      ### Test Helpers and Utilities
      - **Shared assertions** in `tests/extractors/test_helpers.py`:
        - `assert_valid_extraction_result()` - Standard result validation
        - `assert_extraction_error()` - Error case validation
        - `assert_ocr_result()` - OCR-specific validation
      - **Avoid repetitive assertions** - Use helper functions

      ### Integration vs Unit Tests
      - **Unit tests**: Fast, isolated, mock external dependencies
      - **Integration tests**: Real file processing, external services, end-to-end flows
      - **Separation**: Integration tests in `tests/integration/` directory
      - **Timeouts**: Integration tests use timeouts and retry logic
    name: Testing Patterns
    priority: critical
  - content: |
      ### GitHub Actions Workflows
      - **Release**: Automated PyPI publishing via GitHub releases, triggers Docker builds
      - **Docker**: Multi-platform Docker builds (linux/amd64, linux/arm64), triggered by releases
      - **Documentation**: Auto-deploy to GitHub Pages on docs changes
      - **CI**: Comprehensive testing across multiple Python versions and platforms

      ### Docker Variants
      - **Core** (`goldziher/kreuzberg:v4.0.0`): API + Tesseract OCR
      - **EasyOCR** (`goldziher/kreuzberg:v4.0.0-easyocr`): Core + EasyOCR
      - **PaddleOCR** (`goldziher/kreuzberg:v4.0.0-paddle`): Core + PaddleOCR
      - **Vision-Tables** (`goldziher/kreuzberg:v4.0.0-vision-tables`): Core + vision-based table extraction
      - **All** (`goldziher/kreuzberg:v4.0.0-all`): All features included

      ### Manual Triggers
      - Docker builds: `gh workflow run "Publish Docker Images"`
      - Documentation: Auto-deploys on docs/ changes

      ### Common Issues
      - **Docker version detection**: Use `git tag --sort=-version:refname | head -n1` not `git describe`
      - **Docs dependencies**: Use `uv sync --group doc` for proper mkdocs-material[imaging] support
      - **Docker Hub README**: May fail due to permissions, use `continue-on-error: true`
    name: CI/CD and Deployment
    priority: minimal
  - content: |
      ### Workspace Configuration
      The project uses a uv workspace with multiple members:
      - **Root Package** (`.`): The main kreuzberg library (v4.x)
      - **Benchmarks** (`benchmarks/`): Performance benchmarking suite

      ### Installation Commands
      - **Always use this for syncing**: `uv sync --all-extras --all-packages --all-groups`
      - This ensures all workspace members and their dependencies are properly installed

      ### Benchmarks Package Overview
      The benchmarks workspace member includes:
      - Performance testing against other extraction libraries (docling, extractous, markitdown, unstructured)
      - Kreuzberg v3 comparison via `kreuzberg-v3` optional dependency (installed from PyPI)
      - Kreuzberg v4 (current) via workspace reference
      - Comprehensive benchmarking CLI: `python -m src.cli`
      - Test documents in `benchmarks/test_documents/` (94 real-world documents)
      - Reports and visualizations in `benchmarks/reports/` and `benchmarks/visualizations/`
      - Resource profiling with CPU/memory tracking at 100ms intervals
      - 1800s timeout per file extraction

      ### Benchmarks Architecture
      - **Protocol-based extractors**: All extractors implement TextExtractor protocol
      - **Factory pattern**: `get_extractor()` for instantiation
      - **Data models**: msgspec.Struct for serialization (BenchmarkResult, BenchmarkSummary)
      - **Resource monitoring**: ResourceProfiler context manager for all extractions
      - **Error handling**: Wrap all calls in try-except, continue on failures
      - **Cache management**: Clear Kreuzberg cache before benchmarks with `clear_cache_command()`

      ### Benchmarks CLI Commands
      ```bash
      # Run benchmarks
      uv run python -m src.cli benchmark --framework kreuzberg_sync,extractous
      uv run python -m src.cli benchmark --category small --iterations 1

      # Generate reports
      uv run python -m src.cli report --output-format html
      uv run python -m src.cli visualize

      # Quality assessment
      uv run python -m src.cli quality-assess --results-file results/results.json
      ```

      ### Adding New Benchmark Frameworks
      1. Create extractor class in `benchmarks/src/extractors.py` implementing TextExtractor protocol
      2. Add to Framework enum in `benchmarks/src/types.py`
      3. Register in `get_extractor()` factory
      4. Add dependencies to benchmarks pyproject.toml optional-dependencies
      5. Configure format exclusions if needed in `benchmarks/src/config.py`
    name: Workspace and Benchmarks
    priority: high
  - content: |
      ### Optional Dependencies Structure
      ```toml
      [project.optional-dependencies]
      api = ["litestar[standard,structlog,opentelemetry]>=2.1.6"]
      cli = ["click>=8.2.1", "rich>=14.0.0", "tomli>=2.0.0; python_version<'3.11'"]
      crypto = ["playa-pdf[crypto]>=0.6.4"]
      easyocr = ["easyocr>=1.7.2"]
      vision-tables = ["torch>=2.8.0", "transformers>=4.56.2"]
      langdetect = ["fast-langdetect>=0.2.0"]
      paddleocr = ["paddleocr>=3.1.0", "paddlepaddle>=3.1.0", "setuptools>=80.9.0"]
      all = ["kreuzberg[api,cli,crypto,easyocr,vision-tables,langdetect,paddleocr]"]
      ```

      ### Installation Patterns
      - Basic: `pip install kreuzberg`
      - With features: `pip install "kreuzberg[api,cli]"`
      - With crypto support: `pip install "kreuzberg[crypto]"`
      - All features: `pip install "kreuzberg[all]"`
      - Development: `uv sync --all-extras`

      ### Dependencies
      - **Core**: pypdfium2, playa-pdf, python-pptx, etc.
      - **System**: tesseract-ocr, pandoc (via package manager)
      - **Development**: Uses dependency groups in pyproject.toml

      ### Crypto Support
      The `crypto` extra adds cryptographic support for PDF processing:
      - **Purpose**: Enables AES encryption/decryption for password-protected PDFs
      - **Dependencies**: Adds cryptography (~22MB), cffi, and pycparser
      - **Usage**: Required for PDFs with AES encryption (RC4 is supported in base installation)
      - **Password Support**: Supports single password or list of passwords to try in sequence
      - **Size Impact**: Increases installation size by ~24MB due to cryptography package
    name: Package Management
    priority: minimal
sections:
  - content: |
      ### XML Extraction (v4.0)
      - **Implementation**: Rust streaming parser using `quick-xml` in `src/xml.rs`
      - **Features**:
        - Memory-efficient streaming for multi-GB XML files
        - Element counting and unique element tracking
        - Preserves text content while filtering XML structure
        - Optional whitespace preservation
      - **Extractors**: `XMLExtractor` in `_extractors/_xml.py`
      - **Supported MIME types**: `application/xml`, `text/xml`, `image/svg+xml`
      - **Metadata**: `element_count`, `unique_elements`

      ### Plain Text & Markdown Extraction (v4.0)
      - **Implementation**: Rust streaming parser in `src/text.rs`
      - **Features**:
        - Memory-efficient line-by-line streaming for multi-GB text files
        - Markdown metadata extraction: headers, links, code blocks
        - Word count, line count, character count tracking
        - CRLF line ending support
        - Lazy regex compilation for performance
      - **Extractors**: `PlainTextExtractor` in `_extractors/_text.py`
      - **Supported MIME types**: `text/plain`, `text/markdown`, `text/x-markdown`
      - **Metadata (markdown only)**: `headers`, `links`, `code_blocks`, `line_count`, `word_count`, `character_count`

      ### Legacy MS Office Support (v4.0)
      - **Implementation**: LibreOffice conversion via `_extractors/_legacy_office.py`
      - **System Dependency**: Requires LibreOffice installed (optional)
      - **Supported Formats**:
        - Word (.doc) - `LegacyWordExtractor`
        - PowerPoint (.ppt) - `LegacyPresentationExtractor`
      - **Process**: Converts legacy formats to modern formats (DOCX/PPTX) then extracts
      - **Installation**:
        - macOS: `brew install libreoffice`
        - Ubuntu/Debian: `sudo apt-get install libreoffice`
        - RHEL/CentOS/Fedora: `sudo dnf install libreoffice`
        - Docker: Pre-installed in all Kreuzberg images
      - **Detection**: Automatically detects LibreOffice availability

      ### Hybrid Rust-Python Architecture (v4.0)
      - **Rust Modules**:
        - `src/xml.rs`: XML streaming parser with quick-xml
        - `src/text.rs`: Plain text/markdown streaming parser
        - `src/excel.rs`: Excel extraction with calamine
        - `src/pptx/`: PowerPoint extraction with python-pptx
        - `src/email.rs`: Email extraction with mail-parser
        - `src/image_preprocessing.rs`: Image processing with image-rs
        - `src/token_reduction.rs`: Token reduction algorithms
        - `src/quality.rs`: Text quality scoring
        - `src/string_utils.rs`: String utilities (safe_decode, mojibake fixing)
        - `src/cache.rs`: Cache management utilities
      - **Python Integration**: PyO3 bindings in `src/lib.rs`, type stubs in `_internal_bindings.pyi`
      - **Build**: Maturin for building Rust extensions (`maturin develop --release`)
      - **Benefits**: 10-50x performance improvements for text processing operations
    id: v4-features
    name: v4 Features (NEW)
  - content: |
      ### Automatic Language Detection (v4.0+)
      - **Feature**: Automatically detect languages in extracted text
      - **Implementation**: Uses fast-langdetect library for high-performance detection
      - **Configuration**:
        - Enable with `language_detection=LanguageDetectionConfig()` in `ExtractionConfig`
        - Configure confidence thresholds via `LanguageDetectionConfig` parameters
      - **Output**: Results available in `ExtractionResult.detected_languages`
      - **Integration**: Works with all extraction methods and file types
    id: language-detection
    name: Language Detection
  - content: |
      ### Structured Extraction (Issue #55)
      - **Goal**: Enable extraction of structured data from documents using vision models
      - **Implementation**:
        - Extend `ExtractionConfig` with structured extraction fields
        - Support `msgspec.Struct` and Pydantic `BaseModel` as output types
        - Use LiteLLM for vision model integration
        - Implement retry logic with error feedback
      - **Configuration**: Currently programmatic only (no `kreuzberg.toml`)
    id: planned-features
    name: Planned Features
